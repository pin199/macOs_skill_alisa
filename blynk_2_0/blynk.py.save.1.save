import blynklib #библиотека Blynk (перед этим в CMD сделать pip install blynklib)
import subprocess #библиотека для запуска параллельных процессов
import webbrowser #библиотека для работы с веб
import pyautogui #библиотека для эмуляции нажатий клавиш клавиатуры (перед этим в CMD сделать pip install pyautogui)
import ctypes 
import config
import subprocess
#import os

#os.startfile('runas')

BLYNK_AUTH = "rJ8UsbSsxKcFnGBrhnCums5clai_FhRL" #вставить токен

blynk = blynklib.Blynk(BLYNK_AUTH)


#функция для запуска отдельным процессом приложений и команд
def startcmd(cmd):
    PIPE = subprocess.PIPE
    p = subprocess.Popen(cmd, shell = True)
    p.poll();


def keyswork(pinname):
    print ('Сочетание клавиш')
    if len(pinname)==2:
        pyautogui.hotkey(pinname[1])
    elif len(pinname)==3:
        pyautogui.hotkey(pinname[1],pinname[2])
    elif len(pinname)==4:
        pyautogui.hotkey(pinname[1],pinname[2],pinname[3])
    elif len(pinname)==5:
        pyautogui.hotkey(pinname[1],pinname[2],pinname[3],pinname[4])
    elif len(pinname)==6:
        pyautogui.hotkey(pinname[1],pinname[2],pinname[3],pinname[4],pinname[5])
    else:
        pass

def clean_symb (text):
            if not isinstance(text, str):
                raise TypeError('Это не текст')
            for i in [' ','[',']','\"','\'']:
                text = text.replace(i,'')
            return text 

def workwithpin (pinname):
    if pinname[1] == "None":
        ctypes.windll.user32.MessageBoxW(0, "Не указаны параметры для виртуального пина в config.py!", "Blynk Controller by Xottabb14", 0)
    else:
        pinV = pinname[1]
        if pinname[0] == 0:
            print ("Значение: "+pinV) 
            startcmd(pinV)
            print ('открываю '+pinV)
        elif pinname[0] == 1:
            print ("Значение: "+pinV)
            webbrowser.open(pinV)
            print ('открываю сайт '+pinV)
        elif pinname[0] == 2:
            keyswork(pinname)
        else:
            pass

def flask_request_run_alisa:
bgggghtyyy6	flaskFile = ""
	flaskNameFile = ""
	subprocess.call(["cd", flaskFile])
	subprocess.call(["export", "FLASK_APP", "=", flaskNameFile])
	subprocess.call(["python3", "-m", "flask", "run", "--port=80"])

@blynk.handle_event('write V0')
def write_virtual_pin_handler(pin, value):
	if str(value) == "['1']":
		app = "/Applications/Yandex.app/Contents/MacOs/Yandex"
		subprocess.call(["open", app])
#startcmd(app)
		print('открываю' + app)

#---------------------Начало блока функций для виртуальных пинов blynk-----------------
"""
@blynk.handle_event('write V0') #данный пин используем для управления общей громкостью ПК
def write_virtual_pin_handler(pin, value):
    valuepin = clean_symb (str(value))
    volset = (65535/100)*int(valuepin) #в nircmd 65535 уровней громкость, маппим их на наши 100%
    nirpath = config.curpath+"\\nircmd.exe setsysvolume "+str(volset)
    startcmd(nirpath)
    print ("Громкость: "+str(valuepin)+" %")

@blynk.handle_event('write V1')
def write_virtual_pin_handler(pin, value):
    valuepin = str(value)[2:3]
    pinname = config.V1
    if valuepin == "1":
        workwithpin(pinname)
    elif valuepin == "0":
        print ("Выключено")
    else:
        ctypes.windll.user32.MessageBoxW(0, "Формат данного виртуального пина указан неверно в приложении Blynk.", "Blynk Controller by Xottabb14", 0)

@blynk.handle_event('write V2')
def write_virtual_pin_handler(pin, value):
    valuepin = str(value)[2:3]
    pinname = c