import blynklib #библиотека Blynk (перед этим в CMD сделать pip install blynklib)
import subprocess #библиотека для запуска параллельных процессов
import webbrowser #библиотека для работы с веб
import pyautogui #библиотека для эмуляции нажатий клавиш клавиатуры (перед этим в CMD сделать pip install pyautogui)
import ctypes 
import config
import subprocess
import os
import keyboard

#os.startfile('runas')

BLYNK_AUTH = "rJ8UsbSsxKcFnGBrhnCums5clai_FhRL" #вставить токен

blynk = blynklib.Blynk(BLYNK_AUTH)


#функция для запуска отдельным процессом приложений и команд
def startcmd(cmd):
    PIPE = subprocess.PIPE
    p = subprocess.Popen(cmd, shell = True)
    p.poll();


def keyswork(pinname):
    print ('Сочетание клавиш')
    if len(pinname)==2:
        pyautogui.hotkey(pinname[1])
    elif len(pinname)==3:
        pyautogui.hotkey(pinname[1],pinname[2])
    elif len(pinname)==4:
        pyautogui.hotkey(pinname[1],pinname[2],pinname[3])
    elif len(pinname)==5:
        pyautogui.hotkey(pinname[1],pinname[2],pinname[3],pinname[4])
    elif len(pinname)==6:
        pyautogui.hotkey(pinname[1],pinname[2],pinname[3],pinname[4],pinname[5])
    else:
        pass

def clean_symb (text):
            if not isinstance(text, str):
                raise TypeError('Это не текст')
            for i in [' ','[',']','\"','\'']:
                text = text.replace(i,'')
            return text 

def workwithpin (pinname):
    if pinname[1] == "None":
        ctypes.windll.user32.MessageBoxW(0, "Не указаны параметры для виртуального пина в config.py!", "Blynk Controller by Xottabb14", 0)
    else:
        pinV = pinname[1]
        if pinname[0] == 0:
            print ("Значение: "+pinV) 
            startcmd(pinV)
            print ('открываю '+pinV)
        elif pinname[0] == 1:
            print ("Значение: "+pinV)
            webbrowser.open(pinV)
            print ('открываю сайт '+pinV)
        elif pinname[0] == 2:
            keyswork(pinname)
        else:
            pass

def flask_request_run_alisa():
	flaskFile = "/Users/nikolaj/PythonProg/gitSkillAlisa/skill_alisa"
	flaskNameFile = "app.py"
	ngrokFile = "/Users/nikolaj/PythonProg/ngrok"
	
	sub=subprocess.Popen(["/Users/nikolaj/PythonProg/ngrok/ngrok","http", "80"])
	#keyboard.send("Command+N")
	subprocess.Popen(["open","Terminal.app", "ls", "-l"],shell=True)
	#os.system("ls -l")
	#os.system("export FLASK_APP=app.py")
	#sub1=subprocess.run(["export","FLASK_APP","=",flaskNameFile])
	sub2 = subprocess.call(["python3", "-m", "flask", "run", "--port=80"])

#	subprocess.call(["cd", ngrokFile])
#	print("1")
#	subprocess.call(["./ngrok"])

#	subprocess.call(["cd", flaskFile])
#	subprocess.call(["export", "FLASK_APP", "=", flaskNameFile])
#	subprocess.call(["python3", "-m", "flask", "run", "--port=80"])

@blynk.handle_event('write V0')
def write_virtual_pin_handler(pin, value):
	if str(value) == "['1']":
		app = "/Applications/Yandex.app/Contents/MacOs/Yandex"
		subprocess.call(["open", app])
		flask_request_run_alisa()
#startcmd(app)
		print('открываю' + app)

#---------------------Начало блока функций для виртуальных пинов blynk-----------------
"""
@blynk.handle_event('write V0') #данный пин используем для управления общей громкостью ПК
def write_virtual_pin_handler(pin, value):
    valuepin = clean_symb (str(value))
    volset = (65535/100)*int(valuepin) #в nircmd 65535 уровней громкость, маппим их на наши 100%
    nirpath = config.curpath+"\\nircmd.exe setsysvolume "+str(volset)
    startcmd(nirpath)
    print ("Громкость: "+str(valu